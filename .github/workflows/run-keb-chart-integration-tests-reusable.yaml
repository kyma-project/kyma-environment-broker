name: KEB chart integration tests (reusable)

on:
  workflow_call:
    inputs:
      last-k3s-versions:
        description: number of the most recent K3s versions to be used
        required: false
        default: '1'
        type: string
      release:
        description: 'Determines if the workflow is called from release'
        default: "true"
        type: string
      version:
        description: 'Release version'
        default: "0.0.0.0"
        type: string

jobs:
  validate-keb-helm-chart:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v6

    - name: Prepare chart for next KEB version
      run: |
        if [ "${{ inputs.release }}" == "true" ]; then
          scripts/bump_keb_chart.sh ${{ inputs.version }} "release"
        else
          scripts/bump_keb_chart.sh PR-${{ inputs.version }} "pr"
        fi

    - name: Validate KEB helm chart
      run: |
        cd resources/keb
        helm template .

    - name: Enforce env alphabetical order in deployment.yaml (KEB)
      run: scripts/check_env_alphabetical_order.sh resources/keb/templates/deployment.yaml deployment_KEB ports

    - name: Enforce env alphabetical order in runtime-reconciler-deployment.yaml
      run: scripts/check_env_alphabetical_order.sh resources/keb/templates/runtime-reconciler-deployment.yaml runtime_reconciler

    - name: Enforce env alphabetical order in trial-cleanup-job.yaml
      run: scripts/check_env_alphabetical_order.sh resources/keb/templates/trial-cleanup-job.yaml trial_cleanup

    - name: Enforce env alphabetical order in deprovision-retrigger-job.yaml
      run: scripts/check_env_alphabetical_order.sh resources/keb/templates/deprovision-retrigger-job.yaml deprovision_retrigger

    - name: Enforce env alphabetical order in free-cleanup-job.yaml
      run: scripts/check_env_alphabetical_order.sh resources/keb/templates/free-cleanup-job.yaml free_cleanup

    - name: Enforce env alphabetical order in service-binding-cleanup-job.yaml
      run: scripts/check_env_alphabetical_order.sh resources/keb/templates/service-binding-cleanup-job.yaml service_binding_cleanup

    - name: Enforce env alphabetical order in subaccount-sync-deployment.yaml
      run: scripts/check_env_alphabetical_order.sh resources/keb/templates/subaccount-sync-deployment.yaml subaccount_sync
      
    - name: Enforce env alphabetical order in migrator-job.yaml
      run: scripts/check_env_alphabetical_order.sh resources/keb/templates/migrator-job.yaml migrator_job
      
  prepare-tests:
    runs-on: ubuntu-latest
    needs: validate-keb-helm-chart
    outputs:
      versions: ${{ steps.get-versions.outputs.k3s_versions }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - id: get-versions
        name: Get K3s versions
        # prepare json representing GitHub matrix:
        # {"include": [
        #    {"version":"v1.26.10+k3s1"},
        #      ...
        #    {"version":"v1.28.3+k3s1"}
        # ]
        # }
        run: |
          VERSIONS=($(./scripts/testing/get-latest-k3s-releases.sh ${{ inputs.last-k3s-versions }}))
          MATRIX_AS_JSON=$(echo ${VERSIONS[*]} | awk 'END {printf "{\"include\":[";for (i = 1; i < NF; i++) printf "{\"version\":%s},",$i;printf "{\"version\":%s}]}",$i }'|jq -c)
          echo "k3s_versions=${MATRIX_AS_JSON}" >> "${GITHUB_OUTPUT}"

  run-keb-chart-matrix:
    runs-on: ubuntu-latest
    needs: prepare-tests
    timeout-minutes: 5
    strategy:
      matrix: ${{ fromJSON(needs.prepare-tests.outputs.versions) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Prepare K3s cluster and docker registry
        run: "./scripts/testing/k3s-setup.sh ${{ matrix.version }} --wait"
        
      - name: Build and push Docker images to k3s registry
        if: ${{ inputs.release == 'false' }}
        run: ./scripts/testing/build-and-push-images.sh PR-${{ inputs.version }}

      - name: Set global account ID
        run: |
          echo "GLOBAL_ACCOUNT_ID=2f5011af-2fd3-44ba-ac60-eeb1148c2995" >> $GITHUB_ENV

      - name: Install KEB chart
        run: scripts/testing/install_keb.sh ${{ inputs.release }} ${{ inputs.version }}

      - name: Provision an instance
        run: |
          kubectl port-forward -n kcp-system deployment/kcp-kyma-environment-broker 8080:8080 5432:5432 &
          sleep 5
          scripts/testing/provision_instances.sh 1 aws-cluster 361c511f-f939-4621-b228-d0fb79a1fe15 aws-cluster us-east-1 http://localhost:8080

      - name: Get RuntimeID
        run: |
            while [ -z "$RUNTIME_ID" ]; do
              RUNTIME_ID=$(curl --request GET \
              --url http://localhost:8080/runtimes \
              --header 'Content-Type: application/json' \
              --header 'X-Broker-API-Version: 2.16' | jq -r '.data[] | select(.instanceID=="aws-cluster") | .runtimeID')
              if [ -z "$RUNTIME_ID" ]; then
                echo "RuntimeID is empty. Retrying in 5 seconds..."
                curl --request GET \
                --url http://localhost:8080/runtimes \
                --header 'Content-Type: application/json' \
                --header 'X-Broker-API-Version: 2.16' | jq -r '.data[]'
                sleep 5
              fi
            done
            echo "RuntimeID: ${RUNTIME_ID}"
            echo "RUNTIME_ID=$RUNTIME_ID" >> $GITHUB_ENV

      - name: Create kubeconfig secret for runtime
        run: |
          make create-kubeconfig-secret RUNTIME_ID=$RUNTIME_ID

      - name: Create GardenerCluster CR
        run: |
          ./scripts/create_gardener_cluster_cr.sh $GLOBAL_ACCOUNT_ID $RUNTIME_ID
              
      - name: Set RuntimeCR State to Ready
        run: |
          make set-runtime-state RUNTIME_ID=$RUNTIME_ID STATE=Ready

      - name: Create Shoot for first instance
        run: |
          make create-shoot RUNTIME_ID=$RUNTIME_ID

      - name: Wait for provisioning to finish
        run: ./scripts/testing/wait_for_instance_state.sh aws-cluster
        
      - name: Set Kyma state to Ready
        run: make set-kyma-state KYMA_ID=$RUNTIME_ID STATE=Ready

      - name: Set KEB pod name as global env
        run: |
          POD_NAME=$(kubectl get pods -n kcp-system -l app.kubernetes.io/name=kyma-environment-broker -o jsonpath="{.items[0].metadata.name}")
          echo "KEB_POD_NAME=$POD_NAME" >> $GITHUB_ENV

      - name: Check for errors and warnings in KEB logs after provisioning
        run: ./scripts/testing/check-keb-logs.sh "$KEB_POD_NAME"

      - name: Update the instance
        run: scripts/testing/update_instance.sh aws-cluster 361c511f-f939-4621-b228-d0fb79a1fe15 '{"machineType":"m5.xlarge"}' http://localhost:8080

      - name: Wait for updating to finish
        run: ./scripts/testing/wait_for_instance_state.sh aws-cluster
      - name: Assert update totalCount is 1
        run: scripts/testing/assert_runtime_count.sh aws-cluster 1 http://localhost:8080 update

      - name: Check for errors and warnings in KEB logs after update
        run: ./scripts/testing/check-keb-logs.sh "$KEB_POD_NAME" "true"

      - name: Provision second instance to test binding rotation
        run: |
          scripts/testing/provision_instances.sh 1 aws-cluster-2 361c511f-f939-4621-b228-d0fb79a1fe15 aws-cluster-2 us-east-1 http://localhost:8080

      - name: Get second RuntimeID
        run: |
            while [ -z "$RUNTIME_ID_2" ]; do
              RUNTIME_ID_2=$(curl --request GET \
              --url http://localhost:8080/runtimes \
              --header 'Content-Type: application/json' \
              --header 'X-Broker-API-Version: 2.16' | jq -r '.data[] | select(.instanceID=="aws-cluster-2") | .runtimeID')
              if [ -z "$RUNTIME_ID_2" ]; then
                echo "RuntimeID_2 is empty. Retrying in 5 seconds..."
                sleep 5
              fi
            done
            echo "RuntimeID_2: ${RUNTIME_ID_2}"
            echo "RUNTIME_ID_2=$RUNTIME_ID_2" >> $GITHUB_ENV

      - name: Create kubeconfig secret for second runtime
        run: make create-kubeconfig-secret RUNTIME_ID=$RUNTIME_ID_2

      - name: Create GardenerCluster CR for second runtime
        run: ./scripts/create_gardener_cluster_cr.sh $GLOBAL_ACCOUNT_ID $RUNTIME_ID_2

      - name: Set second RuntimeCR State to Ready
        run: make set-runtime-state RUNTIME_ID=$RUNTIME_ID_2 STATE=Ready

      - name: Create Shoot for second instance
        run: |
          make create-shoot RUNTIME_ID=$RUNTIME_ID_2

      - name: Wait for second provisioning to finish
        run: ./scripts/testing/wait_for_instance_state.sh aws-cluster-2
          
      - name: Set second Kyma state to Ready
        run: make set-kyma-state KYMA_ID=$RUNTIME_ID_2 STATE=Ready

      - name: Provision third instance to test limit enforcement
        run: |
          scripts/testing/provision_instances.sh 1 aws-cluster-3 361c511f-f939-4621-b228-d0fb79a1fe15 aws-cluster-3 us-east-1 http://localhost:8080

      - name: Get third RuntimeID
        run: |
            while [ -z "$RUNTIME_ID_3" ]; do
              RUNTIME_ID_3=$(curl --request GET \
              --url http://localhost:8080/runtimes \
              --header 'Content-Type: application/json' \
              --header 'X-Broker-API-Version: 2.16' | jq -r '.data[] | select(.instanceID=="aws-cluster-3") | .runtimeID')
              if [ -z "$RUNTIME_ID_3" ]; then
                echo "RuntimeID_3 is empty. Retrying in 5 seconds..."
                sleep 5
              fi
            done
            echo "RuntimeID_3: ${RUNTIME_ID_3}"
            echo "RUNTIME_ID_3=$RUNTIME_ID_3" >> $GITHUB_ENV

      - name: Create kubeconfig secret for third runtime
        run: make create-kubeconfig-secret RUNTIME_ID=$RUNTIME_ID_3

      - name: Create GardenerCluster CR for third runtime
        run: ./scripts/create_gardener_cluster_cr.sh $GLOBAL_ACCOUNT_ID $RUNTIME_ID_3

      - name: Set third RuntimeCR State to Ready
        run: make set-runtime-state RUNTIME_ID=$RUNTIME_ID_3 STATE=Ready

      - name: Create Shoot for third instance
        run: |
          make create-shoot RUNTIME_ID=$RUNTIME_ID_3

      - name: Wait for third provisioning to finish
        run: ./scripts/testing/wait_for_instance_state.sh aws-cluster-3

      - name: Set third Kyma state to Ready
        run: make set-kyma-state KYMA_ID=$RUNTIME_ID_3 STATE=Ready

      - name: Provision fourth instance
        run: |
          scripts/testing/provision_instances.sh 1 aws-cluster-4 361c511f-f939-4621-b228-d0fb79a1fe15 aws-cluster-4 us-east-1 http://localhost:8080

      - name: Get fourth RuntimeID
        run: |
            while [ -z "$RUNTIME_ID_4" ]; do
              RUNTIME_ID_4=$(curl --request GET \
              --url http://localhost:8080/runtimes \
              --header 'Content-Type: application/json' \
              --header 'X-Broker-API-Version: 2.16' | jq -r '.data[] | select(.instanceID=="aws-cluster-4") | .runtimeID')
              if [ -z "$RUNTIME_ID_4" ]; then
                echo "RuntimeID_4 is empty. Retrying in 5 seconds..."
                sleep 5
              fi
            done
            echo "RuntimeID_4: ${RUNTIME_ID_4}"
            echo "RUNTIME_ID_4=$RUNTIME_ID_4" >> $GITHUB_ENV

      - name: Create kubeconfig secret for fourth runtime
        run: make create-kubeconfig-secret RUNTIME_ID=$RUNTIME_ID_4

      - name: Create GardenerCluster CR for fourth runtime
        run: ./scripts/create_gardener_cluster_cr.sh $GLOBAL_ACCOUNT_ID $RUNTIME_ID_4

      - name: Set fourth RuntimeCR State to Ready
        run: make set-runtime-state RUNTIME_ID=$RUNTIME_ID_4 STATE=Ready

      - name: Create Shoot for fourth instance
        run: |
          make create-shoot RUNTIME_ID=$RUNTIME_ID_4

      - name: Wait for fourth provisioning to finish
        run: ./scripts/testing/wait_for_instance_state.sh aws-cluster-4

      - name: Verify fourth instance got a different credentials binding
        run: |
          BINDING_NAME_1=$(kubectl get runtime $RUNTIME_ID -n kcp-system -o jsonpath='{.spec.shoot.secretBindingName}')
          BINDING_NAME_2=$(kubectl get runtime $RUNTIME_ID_2 -n kcp-system -o jsonpath='{.spec.shoot.secretBindingName}')
          BINDING_NAME_3=$(kubectl get runtime $RUNTIME_ID_3 -n kcp-system -o jsonpath='{.spec.shoot.secretBindingName}')
          BINDING_NAME_4=$(kubectl get runtime $RUNTIME_ID_4 -n kcp-system -o jsonpath='{.spec.shoot.secretBindingName}')
          echo "Verifying binding rotation across four instances"
          echo "Instance 1 binding: $BINDING_NAME_1"
          echo "Instance 2 binding: $BINDING_NAME_2"
          echo "Instance 3 binding: $BINDING_NAME_3"
          echo "Instance 4 binding: $BINDING_NAME_4"
          
          # Verify instances 1, 2, and 3 all share the same binding (below limit of 3)
          if [ "$BINDING_NAME_1" != "$BINDING_NAME_2" ] || [ "$BINDING_NAME_1" != "$BINDING_NAME_3" ]; then
            echo "Error: Instances 1, 2, and 3 should all share the same binding (below limit of 3)"
            echo "Instance 1: $BINDING_NAME_1"
            echo "Instance 2: $BINDING_NAME_2"
            echo "Instance 3: $BINDING_NAME_3"
            exit 1
          fi
          
          # Verify instance 4 has a different binding (limit reached, rotation occurred)
          if [ "$BINDING_NAME_4" == "$BINDING_NAME_1" ]; then
            echo "Error: Instance 4 should have a different binding (limit of 3 reached)"
            echo "Instances 1-3: $BINDING_NAME_1"
            echo "Instance 4: $BINDING_NAME_4"
            exit 1
          fi
          
          echo "Instances 1-3 share binding: $BINDING_NAME_1"
          echo "Instance 4 uses different binding: $BINDING_NAME_4"

      - name: Set fourth Kyma state to Ready
        run: make set-kyma-state KYMA_ID=$RUNTIME_ID_4 STATE=Ready

      - name: Delete Shoot for second instance before deprovisioning
        run: ./scripts/delete_shoot.sh $RUNTIME_ID_2

      - name: Deprovision the second instance
        run: scripts/testing/deprovision_instances.sh 361c511f-f939-4621-b228-d0fb79a1fe15 aws-cluster-2 http://localhost:8080 single
      
      - name: Wait for second instance deprovisioning to finish
        run: ./scripts/testing/wait_for_deprovisioning.sh aws-cluster-2 $RUNTIME_ID_2

      - name: Check for errors and warnings in KEB logs after second instance deprovisioning
        run: ./scripts/testing/check-keb-logs.sh "$KEB_POD_NAME" "true"

      - name: Provision fifth instance
        run: |
          scripts/testing/provision_instances.sh 1 aws-cluster-5 361c511f-f939-4621-b228-d0fb79a1fe15 aws-cluster-5 us-east-1 http://localhost:8080

      - name: Get fifth RuntimeID
        run: |
            while [ -z "$RUNTIME_ID_5" ]; do
              RUNTIME_ID_5=$(curl --request GET \
              --url http://localhost:8080/runtimes \
              --header 'Content-Type: application/json' \
              --header 'X-Broker-API-Version: 2.16' | jq -r '.data[] | select(.instanceID=="aws-cluster-5") | .runtimeID')
              if [ -z "$RUNTIME_ID_5" ]; then
                echo "RuntimeID_5 is empty. Retrying in 5 seconds..."
                sleep 5
              fi
            done
            echo "RuntimeID_5: ${RUNTIME_ID_5}"
            echo "RUNTIME_ID_5=$RUNTIME_ID_5" >> $GITHUB_ENV

      - name: Create kubeconfig secret for fifth runtime
        run: make create-kubeconfig-secret RUNTIME_ID=$RUNTIME_ID_5

      - name: Create GardenerCluster CR for fifth runtime
        run: ./scripts/create_gardener_cluster_cr.sh $GLOBAL_ACCOUNT_ID $RUNTIME_ID_5

      - name: Set fifth RuntimeCR State to Ready
        run: make set-runtime-state RUNTIME_ID=$RUNTIME_ID_5 STATE=Ready

      - name: Create Shoot for fifth instance
        run: |
          make create-shoot RUNTIME_ID=$RUNTIME_ID_5

      - name: Wait for fifth provisioning to finish
        run: ./scripts/testing/wait_for_instance_state.sh aws-cluster-5

      - name: Verify fifth instance got the same credentials binding as instances 1 and 3
        run: |
          BINDING_NAME_1=$(kubectl get runtime $RUNTIME_ID -n kcp-system -o jsonpath='{.spec.shoot.secretBindingName}')
          BINDING_NAME_3=$(kubectl get runtime $RUNTIME_ID_3 -n kcp-system -o jsonpath='{.spec.shoot.secretBindingName}')
          BINDING_NAME_5=$(kubectl get runtime $RUNTIME_ID_5 -n kcp-system -o jsonpath='{.spec.shoot.secretBindingName}')
          echo "Instance 1 binding: $BINDING_NAME_1"
          echo "Instance 3 binding: $BINDING_NAME_3"
          echo "Instance 5 binding: $BINDING_NAME_5"
          
          # Verify fifth instance has the same binding as instances 1 and 3 (reuses freed slot)
          if [ "$BINDING_NAME_5" != "$BINDING_NAME_1" ] || [ "$BINDING_NAME_5" != "$BINDING_NAME_3" ]; then
            echo "Error: Fifth instance should have same binding as instances 1 and 3 (reusing freed slot)"
            echo "Instance 1: $BINDING_NAME_1"
            echo "Instance 3: $BINDING_NAME_3"
            echo "Instance 5: $BINDING_NAME_5"
            exit 1
          fi
          
          echo "Instance 5 shares binding with instances 1 and 3: $BINDING_NAME_5"

      - name: Set fifth Kyma state to Ready
        run: make set-kyma-state KYMA_ID=$RUNTIME_ID_5 STATE=Ready

      - name: Update global account ID
        run: |
          echo "GLOBAL_ACCOUNT_ID=new-globalaccount-id" >> $GITHUB_ENV

      - name: Update the instance with new global account ID
        run: scripts/testing/update_instance.sh aws-cluster 361c511f-f939-4621-b228-d0fb79a1fe15 '{}' http://localhost:8080

      - name: Wait for global account ID update to finish
        run: ./scripts/testing/wait_for_instance_state.sh aws-cluster
      - name: Assert update totalCount is 2
        run: scripts/testing/assert_runtime_count.sh aws-cluster 2 http://localhost:8080 update

      - name: Check for errors and warnings in KEB logs after global account ID update
        run: ./scripts/testing/check-keb-logs.sh "$KEB_POD_NAME" "true"

      - name: Verify global account ID label on Runtime CR
        run: |
          RUNTIME_LABEL=$(kubectl get runtime $RUNTIME_ID -n kcp-system -o jsonpath='{.metadata.labels.kyma-project\.io/global-account-id}')
          echo "Runtime CR global account ID label: $RUNTIME_LABEL"
          if [ "$RUNTIME_LABEL" != "$GLOBAL_ACCOUNT_ID" ]; then
            echo "Error: Runtime CR label does not match expected global account ID"
            echo "Expected: $GLOBAL_ACCOUNT_ID"
            echo "Actual: $RUNTIME_LABEL"
            exit 1
          fi
          echo "Runtime CR label verification passed"

      - name: Verify global account ID label on Kyma CR
        run: |
          KYMA_LABEL=$(kubectl get kyma $RUNTIME_ID -n kcp-system -o jsonpath='{.metadata.labels.kyma-project\.io/global-account-id}')
          echo "Kyma CR global account ID label: $KYMA_LABEL"
          if [ "$KYMA_LABEL" != "$GLOBAL_ACCOUNT_ID" ]; then
            echo "Error: Kyma CR label does not match expected global account ID"
            echo "Expected: $GLOBAL_ACCOUNT_ID"
            echo "Actual: $KYMA_LABEL"
            exit 1
          fi
          echo "Kyma CR label verification passed"

      - name: Verify global account ID label on GardenerCluster CR
        run: |
          GARDENER_LABEL=$(kubectl get gardenercluster $RUNTIME_ID -n kcp-system -o jsonpath='{.metadata.labels.kyma-project\.io/global-account-id}')
          echo "GardenerCluster CR global account ID label: $GARDENER_LABEL"
          if [ "$GARDENER_LABEL" != "$GLOBAL_ACCOUNT_ID" ]; then
            echo "Error: GardenerCluster CR label does not match expected global account ID"
            echo "Expected: $GLOBAL_ACCOUNT_ID"
            echo "Actual: $GARDENER_LABEL"
            exit 1
          fi
          echo "GardenerCluster CR label verification passed"

      - name: Deprovision the instance
        run: scripts/testing/deprovision_instances.sh 361c511f-f939-4621-b228-d0fb79a1fe15 aws-cluster http://localhost:8080 single
      
      - name: Wait for deprovisioning to finish
        run: ./scripts/testing/wait_for_deprovisioning.sh aws-cluster $RUNTIME_ID

      - name: Check for errors and warnings in KEB logs after deprovisioning
        run: ./scripts/testing/check-keb-logs.sh "$KEB_POD_NAME" "true"

      - name: Print runtimes in case of failure
        if: ${{ !success() }}
        run: |
          curl --request GET \
          --url http://localhost:8080/runtimes \
          --header 'Content-Type: application/json' \
          --header 'X-Broker-API-Version: 2.16' | jq

